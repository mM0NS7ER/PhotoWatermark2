# 照片水印应用 - 技术选型文档

## 1. 技术选型概述

根据项目需求和技术架构设计，我们选择了Python作为主要开发语言，PyQt作为GUI框架，结合OpenCV和Pillow进行图像处理。本文档详细说明了各项技术选型的理由和具体实现方案。

## 2. 开发语言与框架

### 2.1 开发语言：Python 3.8+
**选择理由**：
- **开发效率高**：Python语法简洁，开发周期短，适合快速原型开发
- **丰富的库生态**：拥有大量成熟的图像处理和GUI开发库
- **跨平台支持**：Python代码可在Windows、macOS和Linux上运行，便于未来扩展
- **社区活跃**：拥有庞大的开发者社区，遇到问题容易找到解决方案

### 2.2 GUI框架：PyQt 6
**选择理由**：
- **功能强大**：提供丰富的UI组件和功能，满足复杂界面需求
- **跨平台**：支持Windows、macOS和Linux，保证应用在不同平台上的一致体验
- **性能良好**：基于C++开发，性能优于纯Python实现的GUI框架
- **文档完善**：有详细的官方文档和丰富的第三方教程
- **设计工具支持**：Qt Designer可帮助快速设计UI界面

### 2.3 备选GUI框架
- **Tkinter**：Python内置GUI库，轻量级但功能相对有限，不适合复杂界面
- **wxPython**：跨平台GUI框架，但API相对复杂，学习曲线较陡
- **Kivy**：适合触控界面，但对传统桌面应用支持不够完善

## 3. 图像处理库

### 3.1 主要图像处理库：Pillow (PIL Fork)
**选择理由**：
- **易用性高**：API设计直观，适合处理常见图像操作
- **格式支持广**：支持所有主流图像格式，包括JPEG、PNG、BMP、TIFF等
- **功能全面**：提供图像缩放、裁剪、旋转、颜色调整等基础功能
- **与Python无缝集成**：纯Python实现，与PyQt等框架配合使用无障碍

### 3.2 辅助图像处理库：OpenCV
**选择理由**：
- **高级图像处理功能**：提供复杂的图像处理算法，如边缘检测、特征提取等
- **性能优异**：底层使用C++实现，处理大图像时性能更好
- **格式支持**：支持多种图像格式，特别是对科学图像格式支持较好
- **未来扩展性**：为将来可能的高级图像处理功能预留技术基础

### 3.3 其他图像处理库
- **scikit-image**：基于NumPy的图像处理库，提供更多科学图像处理功能
- **matplotlib**：主要用于数据可视化，但也可用于图像显示和处理

## 4. 项目结构设计

### 4.1 目录结构
```
PhotoWatermarkApp/
├── main.py              # 应用入口
├── resources/           # 资源文件
│   ├── icons/           # 图标文件
│   └── styles/          # 样式文件
├── ui/                  # UI层代码
│   ├── __init__.py
│   ├── main_window.py   # 主窗口
│   ├── image_view.py    # 图片列表视图
│   ├── preview_area.py  # 图片预览区
│   ├── watermark_panel.py # 水印控制面板
│   └── export_panel.py  # 导出设置面板
├── core/                # 业务逻辑层代码
│   ├── __init__.py
│   ├── file_processor.py # 文件处理模块
│   ├── watermark_processor.py # 水印处理模块
│   └── config_manager.py # 配置管理模块
├── data/                # 数据访问层代码
│   ├── __init__.py
│   ├── image_storage.py  # 图片存储
│   ├── template_storage.py # 模板存储
│   └── config_storage.py # 配置存储
├── utils/               # 工具类
│   ├── __init__.py
│   ├── image_utils.py   # 图片处理工具
│   └── ui_utils.py      # UI工具函数
└── requirements.txt     # 依赖包列表
```

### 4.2 模块职责说明
- **main.py**: 应用程序入口，负责初始化应用和启动主窗口
- **ui/**: 包含所有用户界面相关代码，实现用户交互
- **core/**: 实现核心业务逻辑，处理水印生成和应用等
- **data/**: 负责数据持久化，包括图片、配置和模板的存储
- **utils/**: 提供通用工具函数，减少代码重复

## 5. 关键技术实现方案

### 5.1 图片导入与显示
```python
# 使用Pillow进行图片导入
from PIL import Image

def load_image(file_path):
    """加载图片文件"""
    try:
        image = Image.open(file_path)
        return image
    except Exception as e:
        print(f"加载图片失败: {e}")
        return None

# 使用QPixmap在Qt中显示图片
from PyQt6.QtGui import QPixmap

def display_image(pil_image, label):
    """在QLabel中显示PIL图片"""
    # 将PIL图像转换为QPixmap
    qimage = ImageQt.ImageQt(pil_image)
    pixmap = QPixmap.fromImage(qimage)

    # 在QLabel中显示
    label.setPixmap(pixmap)
    label.setScaledContents(True)
```

### 5.2 水印生成与应用
```python
from PIL import Image, ImageDraw, ImageFont

def create_text_watermark(text, font_path, font_size, color, opacity, effects=None):
    """创建文本水印图像"""
    # 创建透明背景图像
    dummy_image = Image.new('RGBA', (1, 1))
    draw = ImageDraw.Draw(dummy_image)

    # 获取文本尺寸
    font = ImageFont.truetype(font_path, font_size)
    text_width, text_height = draw.textsize(text, font=font)

    # 创建实际大小的图像
    watermark = Image.new('RGBA', (text_width, text_height), (0, 0, 0, 0))
    draw = ImageDraw.Draw(watermark)

    # 应用文本效果
    if effects:
        if 'shadow' in effects:
            # 添加阴影效果
            shadow_offset = effects['shadow'].get('offset', (2, 2))
            shadow_color = effects['shadow'].get('color', (128, 128, 128))
            shadow_opacity = int(opacity * effects['shadow'].get('opacity', 0.5))

            # 绘制阴影
            draw.text(
                (shadow_offset[0], shadow_offset[1]),
                text, 
                font=font, 
                fill=shadow_color + (shadow_opacity,)
            )

    # 绘制文本
    draw.text((0, 0), text, font=font, fill=color + (int(opacity * 255),))

    return watermark

def apply_watermark(image, watermark, position, opacity=1.0):
    """将水印应用到图片上"""
    if watermark.mode != 'RGBA':
        watermark = watermark.convert('RGBA')

    # 调整水印透明度
    if opacity < 1.0:
        alpha = watermark.split()[3]
        alpha = alpha.point(lambda p: p * opacity)
        watermark.putalpha(alpha)

    # 计算水印位置
    img_width, img_height = image.size
    wm_width, wm_height = watermark.size

    if position == 'top-left':
        x, y = 10, 10
    elif position == 'top-right':
        x, y = img_width - wm_width - 10, 10
    elif position == 'bottom-left':
        x, y = 10, img_height - wm_height - 10
    elif position == 'bottom-right':
        x, y = img_width - wm_width - 10, img_height - wm_height - 10
    elif position == 'center':
        x, y = (img_width - wm_width) // 2, (img_height - wm_height) // 2
    else:  # 自定义位置
        x, y = position

    # 合并图像
    image.paste(watermark, (x, y), watermark)
    return image
```

### 5.3 实时预览实现
```python
class PreviewArea(QWidget):
    """图片预览区"""
    def __init__(self):
        super().__init__()
        self.current_image = None
        self.watermark_image = None
        self.watermark_position = 'center'
        self.dragging = False
        self.drag_start = None

        # 设置布局
        self.layout = QVBoxLayout(self)

        # 预览标签
        self.preview_label = QLabel()
        self.preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(self.preview_label)

        # 启用鼠标事件
        self.setMouseTracking(True)
        self.preview_label.setMouseTracking(True)

    def update_preview(self, image, watermark_params=None):
        """更新预览"""
        if image is None:
            return

        # 创建预览图像副本
        preview_image = image.copy()

        # 如果有水印参数，应用水印
        if watermark_params:
            # 创建水印
            if watermark_params['type'] == 'text':
                watermark = create_text_watermark(
                    watermark_params['text'],
                    watermark_params['font'],
                    watermark_params['font_size'],
                    watermark_params['color'],
                    watermark_params['opacity'],
                    watermark_params.get('effects', {})
                )
            else:  # image watermark
                watermark = watermark_params['image']
                watermark = watermark.resize(
                    (watermark_params['width'], watermark_params['height']),
                    Image.Resampling.LANCZOS
                )
                # 调整透明度
                if watermark_params['opacity'] < 1.0:
                    alpha = watermark.split()[3]
                    alpha = alpha.point(lambda p: p * watermark_params['opacity'])
                    watermark.putalpha(alpha)

            # 应用水印
            preview_image = apply_watermark(
                preview_image, 
                watermark, 
                watermark_params['position']
            )

        # 转换为QPixmap并显示
        qimage = ImageQt.ImageQt(preview_image)
        pixmap = QPixmap.fromImage(qimage)

        # 保存当前图像和参数，用于拖拽处理
        self.current_image = image
        self.watermark_image = watermark if watermark_params else None
        self.watermark_params = watermark_params

        # 显示预览
        self.preview_label.setPixmap(pixmap)
        self.preview_label.setScaledContents(True)
```

## 6. 性能优化策略

### 6.1 图片处理优化
- **多线程处理**：使用Python的`concurrent.futures`或`threading`模块实现多线程批量处理
- **图像缩放**：在预览时适当缩小大尺寸图片，提高显示速度
- **缓存机制**：缓存已处理的水印，避免重复计算

### 6.2 UI响应优化
- **异步操作**：耗时操作（如批量处理）使用`QThread`在后台执行
- **进度反馈**：为长时间操作提供进度条和状态反馈
- **局部更新**：仅在必要的时候更新UI，减少重绘次数

## 7. 依赖管理

### 7.1 核心依赖包
```
PyQt6>=6.0.0
Pillow>=9.0.0
opencv-python>=4.5.0
numpy>=1.21.0
```

### 7.2 开发依赖包
```
pylint>=2.12.0  # 代码质量检查
pytest>=7.0.0    # 单元测试
black>=22.0.0   # 代码格式化
```

## 8. 风险评估与应对

### 8.1 技术风险
- **风险**：Pillow在某些特殊图片格式上可能存在兼容性问题
  **应对**：准备备用图像处理库（如OpenCV）作为后备方案

- **风险**：大量图片处理时内存占用过高
  **应对**：实现图片流式处理，避免一次性加载所有图片到内存

### 8.2 性能风险
- **风险**：实时预览在高分辨率图片上可能不够流畅
  **应对**：实现预览图片的智能缩放，平衡显示质量和性能

## 9. 扩展性考虑

### 9.1 未来功能扩展
- **插件系统**：设计插件接口，支持第三方扩展水印效果
- **云端集成**：预留API接口，支持未来可能的云端存储和同步功能
- **批处理脚本**：支持通过脚本定义复杂的水印处理流程

### 9.2 平台扩展
- **macOS和Linux支持**：采用跨平台技术栈，确保未来可轻松移植到其他平台
- **移动端适配**：考虑未来可能的移动端版本，保持核心逻辑与平台无关
